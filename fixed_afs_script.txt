local ANIME_FIGHTERS_PLACE_ID = 6299805723
if game.PlaceId ~= ANIME_FIGHTERS_PLACE_ID then 
    return warn("Wrong game! This script is for Anime Fighters Simulator only.") 
end

local services = {
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    VirtualInputManager = game:GetService("VirtualInputManager"),
    VirtualUser = game:GetService("VirtualUser"),
    Workspace = game:GetService("Workspace"),
    HttpService = game:GetService("HttpService")
}

local player = services.Players.LocalPlayer
local tweenService = services.TweenService
local virtualInputManager = services.VirtualInputManager

local Player = services.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local PlayerGui = Player.PlayerGui

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

local scriptData = {
    disabled = false,
    selectedWorld = nil,
    selectedMob = nil,
    selectedEgg = nil,
    selectedFuse = nil,
    farmDistance = 100,
    loopSpeed = 0.1,
    maxRetries = 3,
    cooldownTime = 0.5,
    lastAction = 0,
    artiSelected = nil,
    connections = {},
    mobs = {},
    worlds = {},
    eggs = {},
    farmingMobs = {}
}

-- Create a mutable toggles table
local function createToggles()
    return {
        autoEgg = false,
        autoEggCurrent = false,
        autoFarm = false,
        autoFarmAll = false,
        autoFarmDistance = false,
        autoCollect = false,
        autoRaid = false,
        autoTrial = false,
        autoDefense = false,
        autoQuest = false,
        autoFuse = false,
        antiAfk = false,
        hidePets = false
    }
end

local Toggles = createToggles()

local RemoteEvents = {
    Remote = services.ReplicatedStorage:WaitForChild("Remote"),
    Bindable = services.ReplicatedStorage:WaitForChild("Bindable", 5)
}

local Modules = {}
local function safeRequire(path, name)
    local success, result = pcall(function()
        return require(path)
    end)
    if success then
        Modules[name] = result
    else
        warn(string.format("Failed to load module %s: %s", name, tostring(result)))
    end
end

if services.ReplicatedStorage:FindFirstChild("ModuleScripts") then
    local moduleScripts = services.ReplicatedStorage.ModuleScripts
    safeRequire(moduleScripts:FindFirstChild("StatCalc"), "StatCalc")
    safeRequire(moduleScripts:FindFirstChild("NumToString"), "NumToString")
    safeRequire(moduleScripts:FindFirstChild("PetStats"), "PetStats")
    safeRequire(moduleScripts:FindFirstChild("EggStats"), "EggStats")
    safeRequire(moduleScripts:FindFirstChild("WorldData"), "WorldData")
    safeRequire(moduleScripts:FindFirstChild("ConfigValues"), "ConfigValues")
    safeRequire(moduleScripts:FindFirstChild("LocalDairebStore"), "LocalDairebStore")
end

local Utils = {}

function Utils.wait(duration)
    local startTime = tick()
    while tick() - startTime < duration and services.RunService.Heartbeat:Wait() do end
end

function Utils.teleportToPosition(targetCFrame)
    if not targetCFrame then return false end
    
    local currentTime = tick()
    if currentTime - scriptData.lastAction < scriptData.cooldownTime then 
        return false 
    end
    scriptData.lastAction = currentTime
    
    local distance = (HumanoidRootPart.Position - targetCFrame.Position).Magnitude
    if distance < 10 then return true end
    
    HumanoidRootPart.CFrame = targetCFrame
    return true
end

function Utils.getDistance(pos1, pos2)
    return (pos1 - pos2).Magnitude
end

function Utils.getWorlds()
    local worldList = {}
    local worldsFolder = services.Workspace:FindFirstChild("Worlds")
    if worldsFolder then
        for _, world in ipairs(worldsFolder:GetChildren()) do
            if world:IsA("Model") or world:IsA("Folder") then
                table.insert(worldList, world.Name)
            end
        end
    end
    table.sort(worldList)
    return worldList
end

function Utils.getMobs()
    local mobList = {}
    local currentWorld = Player.World and Player.World.Value
    if currentWorld then
        local worldFolder = services.Workspace.Worlds:FindFirstChild(currentWorld)
        if worldFolder and worldFolder:FindFirstChild("Enemies") then
            for _, enemy in ipairs(worldFolder.Enemies:GetChildren()) do
                local displayName = enemy:FindFirstChild("DisplayName")
                if displayName and not table.find(mobList, displayName.Value) then
                    table.insert(mobList, displayName.Value)
                end
            end
        end
    end
    return mobList
end

function Utils.getMobsInDistance(distance)
    local mobsInRange = {}
    local currentWorld = Player.World and Player.World.Value
    if not currentWorld or not HumanoidRootPart then return mobsInRange end
    
    local worldFolder = services.Workspace.Worlds:FindFirstChild(currentWorld)
    if worldFolder and worldFolder:FindFirstChild("Enemies") then
        for _, enemy in ipairs(worldFolder.Enemies:GetChildren()) do
            local humanoidRootPart = enemy:FindFirstChild("HumanoidRootPart")
            local displayName = enemy:FindFirstChild("DisplayName")
            local attackers = enemy:FindFirstChild("Attackers")
            
            if humanoidRootPart and displayName and attackers then
                local dist = Utils.getDistance(HumanoidRootPart.Position, humanoidRootPart.Position)
                if dist <= distance then
                    table.insert(mobsInRange, {
                        enemy = enemy,
                        distance = dist,
                        name = displayName.Value
                    })
                end
            end
        end
    end
    
    table.sort(mobsInRange, function(a, b)
        return a.distance < b.distance
    end)
    
    return mobsInRange
end

function Utils.getEggs()
    local eggList = {}
    if Modules.EggStats then
        for eggName, info in pairs(Modules.EggStats) do
            if info.Currency ~= "Robux" and not info.Hidden then
                local displayText = string.format("%s (%s)", info.DisplayName or eggName, eggName)
                table.insert(eggList, displayText)
            end
        end
    end
    return eggList
end

function Utils.getPets()
    if Modules.LocalDairebStore then
        local store = Modules.LocalDairebStore
        local gameData = store.GetStoreProxy("GameData")
        return gameData:GetData("Pets") or {}
    end
    return {}
end

function Utils.equipArtifact(artifactName)
    if not artifactName then return false end
    
    local success, result = pcall(function()
        local args = {artifactName, "CurrentSecondArtefact"}
        RemoteEvents.Remote:FindFirstChild("EquipArtefact"):FireServer(unpack(args))
        return true
    end)
    
    return success
end

local scriptFunctions = {}

function scriptFunctions.openEgg(eggName, teleport)
    if scriptData.disabled then return false end
    
    local attempts = 0
    local success = false
    
    while attempts < scriptData.maxRetries and not success do
        local openSuccess, result = pcall(function()
            if teleport and eggName then
                local eggModel = services.Workspace.Worlds:FindFirstChild(eggName .. "Egg")
                if eggModel and Utils.teleportToPosition(eggModel:GetPivot()) then
                    Utils.wait(0.3)
                end
            end
            
            local remote = RemoteEvents.Remote:FindFirstChild("AttemptMultiOpen")
            if remote then
                remote:FireServer(eggName)
                return true
            end
            return false
        end)
        
        if openSuccess and result then
            success = true
        else
            attempts = attempts + 1
            if attempts < scriptData.maxRetries then
                Utils.wait(0.1)
            end
        end
    end
    
    return success
end

function scriptFunctions.farmMob(mobName)
    if scriptData.disabled then return false end
    
    local currentWorld = Player.World and Player.World.Value
    if not currentWorld then return false end
    
    local worldFolder = services.Workspace.Worlds:FindFirstChild(currentWorld)
    if not worldFolder then return false end
    
    local enemies = worldFolder:FindFirstChild("Enemies")
    if not enemies then return false end
    
    for _, enemy in ipairs(enemies:GetChildren()) do
        local displayName = enemy:FindFirstChild("DisplayName")
        local humanoidRootPart = enemy:FindFirstChild("HumanoidRootPart")
        local attackers = enemy:FindFirstChild("Attackers")
        
        if displayName and displayName.Value == mobName and humanoidRootPart and attackers then
            Utils.teleportToPosition(humanoidRootPart.CFrame)
            
            local success, result = pcall(function()
                if RemoteEvents.Bindable and RemoteEvents.Bindable:FindFirstChild("SendPet") then
                    RemoteEvents.Bindable.SendPet:Fire(enemy, true)
                end
            end)
            
            return success
        end
    end
    
    return false
end

function scriptFunctions.farmMobsInDistance()
    if scriptData.disabled or not Toggles.autoFarmDistance then return end
    
    local mobsInRange = Utils.getMobsInDistance(scriptData.farmDistance)
    
    for _, mobData in ipairs(mobsInRange) do
        if not Toggles.autoFarmDistance or scriptData.disabled then break end
        
        local enemy = mobData.enemy
        local success, result = pcall(function()
            if RemoteEvents.Bindable and RemoteEvents.Bindable:FindFirstChild("SendPet") then
                RemoteEvents.Bindable.SendPet:Fire(enemy, true)
            end
        end)
        
        if success then
            scriptData.farmingMobs[enemy] = true
        end
    end
end

function scriptFunctions.collectDrops()
    if scriptData.disabled then return end
    
    pcall(function()
        local effects = services.Workspace:FindFirstChild("Effects")
        if effects then
            for _, effect in ipairs(effects:GetDescendants()) do
                if effect.Name == "Base" and effect:IsA("BasePart") then
                    effect.CFrame = HumanoidRootPart.CFrame
                end
            end
        end
    end)
end

function scriptFunctions.autoFuse()
    if scriptData.disabled or not scriptData.selectedFuse then return false end
    
    local pets = Utils.getPets()
    local petToFuse = nil
    local fuseablePets = {}
    
    for _, pet in pairs(pets) do
        if tostring(pet.UID) == scriptData.selectedFuse then
            petToFuse = pet.UID
            break
        end
    end
    
    if not petToFuse then return false end
    
    local equippedPets = {}
    for _, petObj in ipairs(Player.Pets:GetChildren()) do
        if petObj.Value and petObj.Value.Data and petObj.Value.Data.UID then
            equippedPets[petObj.Value.Data.UID.Value] = true
        end
    end
    
    for _, pet in pairs(pets) do
        if not equippedPets[pet.UID] and pet.UID ~= petToFuse then
            table.insert(fuseablePets, pet.UID)
        end
    end
    
    if #fuseablePets > 0 then
        local success, result = pcall(function()
            RemoteEvents.Remote:FindFirstChild("FeedPets"):FireServer(fuseablePets, petToFuse)
            return true
        end)
        return success
    end
    
    return false
end

function scriptFunctions.initAntiAfk()
    if scriptData.connections.antiAfk then return end
    
    scriptData.connections.antiAfk = Player.Idled:Connect(function()
        services.VirtualUser:Button2Down(Vector2.new(0, 0), services.Workspace.CurrentCamera.CFrame)
        task.wait(1)
        services.VirtualUser:Button2Up(Vector2.new(0, 0), services.Workspace.CurrentCamera.CFrame)
    end)
end

local Advanced = {}

function Advanced.autoRaid()
    if scriptData.disabled or Player.World.Value ~= "Raid" then return end
    
    local enemies = services.Workspace.Worlds.Raid.Enemies
    
    for _, enemy in ipairs(enemies:GetChildren()) do
        if enemy:FindFirstChild("HumanoidRootPart") and enemy:FindFirstChild("Attackers") then
            pcall(function()
                Utils.teleportToPosition(enemy.HumanoidRootPart.CFrame)
                if RemoteEvents.Bindable and RemoteEvents.Bindable:FindFirstChild("SendPet") then
                    RemoteEvents.Bindable.SendPet:Fire(enemy, true)
                end
            end)
        end
    end
end

function Advanced.autoTrial()
    if scriptData.disabled or Player.World.Value ~= "Tower" then return end
    
    local enemies = services.Workspace.Worlds.Tower.Enemies
    for _, enemy in ipairs(enemies:GetChildren()) do
        if enemy:FindFirstChild("HumanoidRootPart") and enemy:FindFirstChild("Attackers") then
            pcall(function()
                Utils.teleportToPosition(enemy.HumanoidRootPart.CFrame)
                if RemoteEvents.Bindable and RemoteEvents.Bindable:FindFirstChild("SendPet") then
                    RemoteEvents.Bindable.SendPet:Fire(enemy, true)
                end
            end)
        end
    end
end

function Advanced.autoQuest()
    if scriptData.disabled then return end
    
    local currentWorld = Player.World and Player.World.Value
    if currentWorld then
        pcall(function()
            local npc = services.Workspace.Worlds[currentWorld]:FindFirstChild(currentWorld)
            if npc then
                RemoteEvents.Remote:FindFirstChild("StartQuest"):FireServer(npc)
                RemoteEvents.Remote:FindFirstChild("FinishQuest"):FireServer(npc)
                RemoteEvents.Remote:FindFirstChild("FinishQuestline"):FireServer(npc)
            end
        end)
    end
end

local QuestTracker = {
    lastQuestText = "",
    currentTarget = nil,
    currentKilled = 0,
    requiredKills = 0,
    questCompleted = false,
    questCheckInterval = 0.5,
    lastQuestCheck = 0,
    questChainActive = false,
    consecutiveQuestAttempts = 0,
    maxQuestAttempts = 3
}

function QuestTracker.parseQuestText(questText)
    if not questText or questText == "" then
        return nil, 0, 0
    end
    
    local pattern = "%[(%d+)/(%d+)%]%s*(.+)"
    local killed, required, mobName = string.match(questText, pattern)
    
    if killed and required and mobName then
        return mobName:trim(), tonumber(killed), tonumber(required)
    end
    
    return nil, 0, 0
end

function QuestTracker.getCurrentQuestInfo()
    local success, result = pcall(function()
        local questUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("MainGui")
        if not questUI then return nil end
        
        local quest = questUI:FindFirstChild("Quest")
        if not quest then return nil end
        
        local objectives = quest:FindFirstChild("Objectives")
        if not objectives then return nil end
        
        local questText = objectives:FindFirstChild("QuestText")
        if not questText then return nil end
        
        local contentText = questText:FindFirstChild("ContentText")
        if not contentText then return nil end
        
        return contentText.Text
    end)
    
    return success and result or nil
end

function QuestTracker.findTargetMob(mobName)
    if not mobName then return nil end
    
    local currentWorld = Player.World and Player.World.Value
    if not currentWorld then return nil end
    
    local worldFolder = services.Workspace.Worlds:FindFirstChild(currentWorld)
    if not worldFolder or not worldFolder:FindFirstChild("Enemies") then return nil end
    
    for _, enemy in ipairs(worldFolder.Enemies:GetChildren()) do
        local displayName = enemy:FindFirstChild("DisplayName")
        if displayName and displayName.Value == mobName then
            local humanoidRootPart = enemy:FindFirstChild("HumanoidRootPart")
            local attackers = enemy:FindFirstChild("Attackers")
            if humanoidRootPart and attackers then
                return enemy
            end
        end
    end
    
    return nil
end

function QuestTracker.attackTargetMob(enemy)
    if not enemy or not enemy.Parent then return false end
    
    local humanoidRootPart = enemy:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    local success = Utils.teleportToPosition(humanoidRootPart.CFrame)
    if not success then return false end
    
    local attackSuccess = pcall(function()
        if RemoteEvents.Bindable and RemoteEvents.Bindable:FindFirstChild("SendPet") then
            RemoteEvents.Bindable.SendPet:Fire(enemy, true)
            return true
        end
        return false
    end)
    
    return attackSuccess
end

function QuestTracker.startQuest()
    local currentWorld = Player.World and Player.World.Value
    if not currentWorld then return false end
    
    QuestTracker.consecutiveQuestAttempts = QuestTracker.consecutiveQuestAttempts + 1
    
    if QuestTracker.consecutiveQuestAttempts > QuestTracker.maxQuestAttempts then
        print("Max quest attempts reached, waiting before retry...")
        task.wait(5)
        QuestTracker.consecutiveQuestAttempts = 0
        return false
    end
    
    local success = pcall(function()
        local npc = services.Workspace.Worlds[currentWorld]:FindFirstChild(currentWorld)
        if npc then
            RemoteEvents.Remote:FindFirstChild("StartQuest"):FireServer(npc)
            QuestTracker.questChainActive = true
            print("Starting new quest in world: " .. currentWorld)
            return true
        end
        return false
    end)
    
    return success
end

function QuestTracker.finishQuest()
    local currentWorld = Player.World and Player.World.Value
    if not currentWorld then return false end
    
    local success = pcall(function()
        local npc = services.Workspace.Worlds[currentWorld]:FindFirstChild(currentWorld)
        if npc then
            RemoteEvents.Remote:FindFirstChild("FinishQuest"):FireServer(npc)
            RemoteEvents.Remote:FindFirstChild("FinishQuestline"):FireServer(npc)
            print("Quest finished in world: " .. currentWorld)
            QuestTracker.consecutiveQuestAttempts = 0
            return true
        end
        return false
    end)
    
    return success
end

function Advanced.enhancedAutoQuest()
    if scriptData.disabled or not Toggles.autoQuest then return end
    
    local currentTime = tick()
    if currentTime - QuestTracker.lastQuestCheck < QuestTracker.questCheckInterval then
        if QuestTracker.currentTarget and QuestTracker.currentKilled < QuestTracker.requiredKills then
            local targetMob = QuestTracker.findTargetMob(QuestTracker.currentTarget)
            if targetMob then
                QuestTracker.attackTargetMob(targetMob)
            end
        end
        return
    end
    
    QuestTracker.lastQuestCheck = currentTime
    
    local questText = QuestTracker.getCurrentQuestInfo()
    
    if not questText or questText == "" or questText:find("No active quest") or questText:find("Complete") then
        if not QuestTracker.questCompleted then
            print("No quest found, starting new quest...")
            QuestTracker.startQuest()
        else
            print("Quest completed, starting new quest...")
            QuestTracker.questCompleted = false
            task.wait(0.5)
            QuestTracker.startQuest()
        end
        
        QuestTracker.currentTarget = nil
        QuestTracker.currentKilled = 0
        QuestTracker.requiredKills = 0
        QuestTracker.lastQuestText = ""
        
        task.wait(1)
        return
    end
    
    local mobName, killed, required = QuestTracker.parseQuestText(questText)
    
    if not mobName then
        print("Unable to parse quest text: " .. tostring(questText))
        
        if questText:find("Collect") or questText:find("Open") or questText:find("Upgrade") then
            print("Non-combat quest detected, handling...")
            task.wait(1)
            QuestTracker.finishQuest()
            task.wait(1)
            QuestTracker.startQuest()
        end
        return
    end
    
    if mobName ~= QuestTracker.currentTarget or (killed == 0 and QuestTracker.currentKilled > 0) then
        print(string.format("New quest detected: %s [%d/%d] (Previous: %s)", 
            mobName, killed, required, tostring(QuestTracker.currentTarget)))
        QuestTracker.questCompleted = false
        QuestTracker.lastQuestText = ""
    end
    
    QuestTracker.currentTarget = mobName
    QuestTracker.currentKilled = killed
    QuestTracker.requiredKills = required
    
    if questText ~= QuestTracker.lastQuestText then
        QuestTracker.lastQuestText = questText
        print(string.format("Quest Progress: %s [%d/%d]", mobName, killed, required))
    end
    
    if killed >= required then
        if not QuestTracker.questCompleted then
            QuestTracker.questCompleted = true
            print("Quest completed! Finishing and preparing for next quest...")
            
            QuestTracker.finishQuest()
            
            task.spawn(function()
                task.wait(2)
                print("Attempting to start next quest in chain...")
                QuestTracker.startQuest()
                
                task.wait(1)
                QuestTracker.currentTarget = nil
                QuestTracker.currentKilled = 0
                QuestTracker.requiredKills = 0
                QuestTracker.questCompleted = false
                QuestTracker.lastQuestText = ""
            end)
        end
        return
    end
    
    local targetMob = QuestTracker.findTargetMob(mobName)
    if targetMob then
        QuestTracker.attackTargetMob(targetMob)
    else
        local currentWorld = Player.World and Player.World.Value
        if currentWorld then
            local worldFolder = services.Workspace.Worlds:FindFirstChild(currentWorld)
            if worldFolder and worldFolder:FindFirstChild("Enemies") then
                for _, enemy in ipairs(worldFolder.Enemies:GetChildren()) do
                    local displayName = enemy:FindFirstChild("DisplayName")
                    if displayName then
                        local enemyName = displayName.Value:lower()
                        local targetName = mobName:lower()
                        
                        if enemyName:find(targetName) or targetName:find(enemyName) then
                            local humanoidRootPart = enemy:FindFirstChild("HumanoidRootPart")
                            local attackers = enemy:FindFirstChild("Attackers")
                            if humanoidRootPart and attackers then
                                QuestTracker.attackTargetMob(enemy)
                                break
                            end
                        end
                    end
                end
            end
        end
    end
end

if not string.trim then
    function string.trim(s)
        return s:match'^()%s*$' and '' or s:match'^%s*(.*%S)'
    end
end

Advanced.autoQuest = Advanced.enhancedAutoQuest

function EquipArtifact(artifact)
    local args = {
        artifact,
        "CurrentSecondArtefact"
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Remote"):WaitForChild("EquipArtefact"):FireServer(unpack(args))
end

-- Function to safely reset toggles
local function resetAllToggles(optionsTable)
    -- Create new toggles instead of modifying readonly table
    local newToggles = createToggles()
    newToggles.antiAfk = Toggles.antiAfk -- Preserve anti-afk state
    
    -- Update the reference
    Toggles = newToggles
    
    -- Update UI toggles
    if optionsTable then
        for optionName, option in pairs(optionsTable) do
            if option.SetValue and optionName ~= "AntiAfk" then
                pcall(function()
                    option:SetValue(false)
                end)
            end
        end
    end
end

local function createFluentUI()
    local Window = Fluent:CreateWindow({
        Title = "Nanashi Hub | AFS",
        SubTitle = "by no name",
        TabWidth = 160,
        Size = UDim2.fromOffset(580, 460),
        Acrylic = true,
        Theme = "Dark",
        MinimizeKey = Enum.KeyCode.LeftControl
    })
    
    local Tabs = {
        Farming = Window:AddTab({ Title = "Farming", Icon = "zap" }),
        Main = Window:AddTab({ Title = "Eggs", Icon = "home" }),
        Advanced = Window:AddTab({ Title = "Advanced", Icon = "settings" }),
        Arte = Window:AddTab({ Title = "Artifacts", Icon = "star" }),
        Misc = Window:AddTab({ Title = "Misc", Icon = "more-horizontal" })
    }
    
    local Options = Fluent.Options
    
    -- Main Tab
    do
        local worldDropdown = Tabs.Main:AddDropdown("WorldSelect", {
            Title = "Select World",
            Values = Utils.getWorlds(),
            Multi = false,
            Default = ""
        })
        
        worldDropdown:OnChanged(function(Value)
            scriptData.selectedWorld = Value
        end)
        
        local autoEggToggle = Tabs.Main:AddToggle("AutoEgg", {
            Title = "Auto Open Egg",
            Default = false
        })
        
        autoEggToggle:OnChanged(function(Value)
            Toggles.autoEgg = Value
            if Value then
                Toggles.autoEggCurrent = false
                if Options.AutoEggCurrent then
                    Options.AutoEggCurrent:SetValue(false)
                end
            end
        end)
        
        local autoEggCurrentToggle = Tabs.Main:AddToggle("AutoEggCurrent", {
            Title = "Auto Open Egg (Current World)",
            Default = false
        })
        
        autoEggCurrentToggle:OnChanged(function(Value)
            Toggles.autoEggCurrent = Value
            if Value then
                Toggles.autoEgg = false
                if Options.AutoEgg then
                    Options.AutoEgg:SetValue(false)
                end
            end
        end)
        
        Tabs.Main:AddButton({
            Title = "TP to Selected World",
            Description = "Teleport to selected world",
            Callback = function()
                if scriptData.selectedWorld and scriptData.selectedWorld ~= "" then
                    local success, result = pcall(function()
                        RemoteEvents.Remote.AttemptTravel:InvokeServer(scriptData.selectedWorld)
                        if services.Workspace.Worlds:FindFirstChild(scriptData.selectedWorld) then
                            local spawn = services.Workspace.Worlds[scriptData.selectedWorld].Spawns.SpawnLocation
                            HumanoidRootPart.CFrame = spawn.CFrame + Vector3.new(0, 5, 0)
                        end
                    end)
                    if success then
                        Fluent:Notify({
                            Title = "Success",
                            Content = "Teleported to " .. scriptData.selectedWorld,
                            Duration = 3
                        })
                    end
                else
                    Fluent:Notify({
                        Title = "Error",
                        Content = "No world selected!",
                        Duration = 3
                    })
                end
            end
        })
    end
    
    -- Farming Tab
    do
        local mobDropdown = Tabs.Farming:AddDropdown("MobSelect", {
            Title = "Select Mob",
            Values = Utils.getMobs(),
            Multi = false,
            Default = ""
        })
        
        mobDropdown:OnChanged(function(Value)
            scriptData.selectedMob = Value
        end)
        
        Tabs.Farming:AddButton({
            Title = "Refresh Mobs",
            Description = "Update mob list for current world",
            Callback = function()
                scriptData.mobs = Utils.getMobs()
                if Options.MobSelect then
                    Options.MobSelect:SetValues(scriptData.mobs)
                end
                Fluent:Notify({
                    Title = "Updated",
                    Content = string.format("Found %d mobs in current world", #scriptData.mobs),
                    Duration = 3
                })
            end
        })
        
        local autoFarmToggle = Tabs.Farming:AddToggle("AutoFarm", {
            Title = "Auto Farm Selected Mob",
            Default = false
        })
        
        autoFarmToggle:OnChanged(function(Value)
            Toggles.autoFarm = Value
            if Value then
                Toggles.autoFarmDistance = false
                if Options.AutoFarmDistance then
                    Options.AutoFarmDistance:SetValue(false)
                end
            end
        end)
        
        local farmDistanceSlider = Tabs.Farming:AddSlider("FarmDistance", {
            Title = "Farm Distance",
            Description = "Distance to farm mobs around you",
            Default = 200,
            Min = 50,
            Max = 500,
            Rounding = 0
        })
        
        farmDistanceSlider:OnChanged(function(Value)
            scriptData.farmDistance = Value
        end)
        
        local autoFarmDistanceToggle = Tabs.Farming:AddToggle("AutoFarmDistance", {
            Title = "Farm All Mobs in Distance",
            Description = "Farm all mobs within the specified distance",
            Default = false
        })
        
        autoFarmDistanceToggle:OnChanged(function(Value)
            Toggles.autoFarmDistance = Value
            if Value then
                Toggles.autoFarm = false
                if Options.AutoFarm then
                    Options.AutoFarm:SetValue(false)
                end
            end
        end)
        
        local autoCollectToggle = Tabs.Farming:AddToggle("AutoCollect", {
            Title = "Auto Collect Drops",
            Default = false
        })
        
        autoCollectToggle:OnChanged(function(Value)
            Toggles.autoCollect = Value
        end)
    end
    
    -- Advanced Tab
    do
        local autoRaidToggle = Tabs.Advanced:AddToggle("AutoRaid", {
            Title = "Auto Raid",
            Default = false
        })
        
        autoRaidToggle:OnChanged(function(Value)
            Toggles.autoRaid = Value
        end)
        
        local autoTrialToggle = Tabs.Advanced:AddToggle("AutoTrial", {
            Title = "Auto Trial",
            Default = false
        })
        
        autoTrialToggle:OnChanged(function(Value)
            Toggles.autoTrial = Value
        end)
        
        local autoQuestToggle = Tabs.Advanced:AddToggle("AutoQuest", {
            Title = "Auto Quest",
            Default = false
        })
        
        autoQuestToggle:OnChanged(function(Value)
            Toggles.autoQuest = Value
        end)
        
        local autoFuseToggle = Tabs.Advanced:AddToggle("AutoFuse", {
            Title = "Auto Fuse Pets",
            Default = false
        })
        
        autoFuseToggle:OnChanged(function(Value)
            Toggles.autoFuse = Value
        end)
        
        local loopSpeedSlider = Tabs.Advanced:AddSlider("LoopSpeed", {
            Title = "Loop Speed",
            Description = "Adjust script loop speed (seconds)",
            Default = 0.1,
            Min = 0.05,
            Max = 2,
            Rounding = 2
        })
        
        loopSpeedSlider:OnChanged(function(Value)
            scriptData.loopSpeed = Value
        end)
        
        Tabs.Advanced:AddButton({
            Title = "Stop all",
            Description = "Stop all farming activities",
            Callback = function()
                -- Use the safe reset function instead of directly modifying Toggles
                resetAllToggles(Options)
                
                Fluent:Notify({
                    Title = "Stopped",
                    Content = "All actions stopped",
                    Duration = 3
                })
            end
        })
    end
    
    -- Artifacts Tab
    do
        local arti = {"Drops", "Luck", "Time", "Dungeon", "Dreams"}
        
        local ArtiDropdown = Tabs.Arte:AddDropdown("ArtiDropdown", {
            Title = "Choose An Artifact To Equip | Slot 2",
            Values = arti,
            Multi = false,
            Default = "",
        })
        
        ArtiDropdown:OnChanged(function(Value)
            scriptData.artiSelected = Value
        end)
        
        Tabs.Arte:AddButton({
            Title = "Equip",
            Description = "Equip selected artifact",
            Callback = function()
                if scriptData.artiSelected then
                    EquipArtifact(scriptData.artiSelected)
                    Fluent:Notify({
                        Title = "Success",
                        Content = "Equipped " .. scriptData.artiSelected,
                        Duration = 3
                    })
                else
                    Fluent:Notify({
                        Title = "Error",
                        Content = "No artifact selected",
                        Duration = 3
                    })
                end
            end
        })
    end
    
    -- Misc Tab
    do
        local antiAfkToggle = Tabs.Misc:AddToggle("AntiAfk", {
            Title = "Anti-AFK",
            Default = true
        })
        
        antiAfkToggle:OnChanged(function(Value)
            Toggles.antiAfk = Value
            if Value then
                scriptFunctions.initAntiAfk()
            elseif scriptData.connections.antiAfk then
                scriptData.connections.antiAfk:Disconnect()
                scriptData.connections.antiAfk = nil
            end
        end)
        
        Tabs.Misc:AddButton({
            Title = "FPS Boost",
            Description = "Optimize game performance",
            Callback = function()
                pcall(function()
                    settings().Rendering.QualityLevel = 1
                    
                    local lighting = game:GetService("Lighting")
                    lighting.GlobalShadows = false
                    lighting.FogEnd = math.huge
                    
                    local terrain = services.Workspace:FindFirstChildOfClass('Terrain')
                    if terrain then
                        terrain.WaterWaveSize = 0
                        terrain.WaterWaveSpeed = 0
                        terrain.WaterReflectance = 0
                        terrain.WaterTransparency = 0
                    end
                end)
                
                Fluent:Notify({
                    Title = "FPS Boost",
                    Content = "Performance optimized",
                    Duration = 3
                })
            end
        })
        
        Tabs.Misc:AddButton({
            Title = "Hide Script",
            Description = "Hide the script interface",
            Callback = function()
                Window:Minimize()
            end
        })
    end
    
    return Window
end

local function createToggleButton()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "DraggableControlButton"
    screenGui.Parent = player.PlayerGui
    screenGui.ResetOnSpawn = false
    
    local button = Instance.new("TextButton")
    button.Name = "ControlButton"
    button.Parent = screenGui
    button.Size = UDim2.new(0, 60, 0, 60)
    button.Position = UDim2.new(0, 100, 0, 100)
    button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    button.BorderSizePixel = 0
    button.Text = "●"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextScaled = true
    button.Font = Enum.Font.GothamBold
    button.Active = true
    button.Draggable = true
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = button
    
    local shadow = Instance.new("Frame")
    shadow.Name = "Shadow"
    shadow.Parent = button
    shadow.Size = UDim2.new(1, 4, 1, 4)
    shadow.Position = UDim2.new(0, 2, 0, 2)
    shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    shadow.BackgroundTransparency = 0.7
    shadow.BorderSizePixel = 0
    shadow.ZIndex = button.ZIndex - 1
    
    local shadowCorner = Instance.new("UICorner")
    shadowCorner.CornerRadius = UDim.new(0, 12)
    shadowCorner.Parent = shadow
    
    local originalSize = button.Size
    local hoverSize = UDim2.new(0, 65, 0, 65)
    
    local hoverTween = tweenService:Create(
        button,
        TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Size = hoverSize, BackgroundColor3 = Color3.fromRGB(55, 55, 55)}
    )
    
    local unhoverTween = tweenService:Create(
        button,
        TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Size = originalSize, BackgroundColor3 = Color3.fromRGB(45, 45, 45)}
    )
    
    button.MouseEnter:Connect(function()
        hoverTween:Play()
    end)
    
    button.MouseLeave:Connect(function()
        unhoverTween:Play()
    end)
    
    local clickTween = tweenService:Create(
        button,
        TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Size = UDim2.new(0, 55, 0, 55), BackgroundColor3 = Color3.fromRGB(35, 35, 35)}
    )
    
    local unclickTween = tweenService:Create(
        button,
        TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Size = originalSize, BackgroundColor3 = Color3.fromRGB(45, 45, 45)}
    )
    
    button.MouseButton1Click:Connect(function()
        clickTween:Play()
        
        pcall(function()
            virtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftControl, false, game)
            task.wait(0.05)
            virtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftControl, false, game)
        end)
        
        button.Text = "UI"
        task.wait(0.1)
        button.Text = "●"
        
        unclickTween:Play()
    end)
    
    button.ZIndex = 999
    shadow.ZIndex = 998
    
    return screenGui
end

local function startMainLoops()
    scriptData.connections.autoEgg = services.RunService.Heartbeat:Connect(function()
        if scriptData.disabled then return end
        
        if Toggles.autoEgg and scriptData.selectedWorld then
            local eggName = scriptData.selectedWorld .. "Egg"
            scriptFunctions.openEgg(eggName, false)
        elseif Toggles.autoEggCurrent then
            local currentWorld = Player.World and Player.World.Value
            if currentWorld then
                local eggName = currentWorld .. "Egg"
                scriptFunctions.openEgg(eggName, false)
            end
        end
        
        Utils.wait(scriptData.loopSpeed)
    end)
    
    scriptData.connections.autoFarm = services.RunService.Heartbeat:Connect(function()
        if scriptData.disabled then return end
        
        if Toggles.autoFarm and scriptData.selectedMob then
            scriptFunctions.farmMob(scriptData.selectedMob)
        elseif Toggles.autoFarmDistance then
            scriptFunctions.farmMobsInDistance()
        end
        
        if Toggles.autoCollect then
            scriptFunctions.collectDrops()
        end
        
        Utils.wait(scriptData.loopSpeed)
    end)
    
    scriptData.connections.advanced = services.RunService.Heartbeat:Connect(function()
        if scriptData.disabled then return end
        
        if Toggles.autoRaid then
            Advanced.autoRaid()
        end
        
        if Toggles.autoTrial then
            Advanced.autoTrial()
        end
        
        if Toggles.autoQuest then
            Advanced.enhancedAutoQuest()
        end
        
        if Toggles.autoFuse then
            scriptFunctions.autoFuse()
        end
        
        Utils.wait(scriptData.loopSpeed * 2)
    end)
end

local function onCharacterAdded(char)
    Character = char
    HumanoidRootPart = char:WaitForChild("HumanoidRootPart")
end

Player.CharacterAdded:Connect(onCharacterAdded)

local function cleanup()
    scriptData.disabled = true
    for name, connection in pairs(scriptData.connections) do
        if connection then
            connection:Disconnect()
        end
    end
end

services.Players.PlayerRemoving:Connect(function(player)
    if player == Player then
        cleanup()
    end
end)

-- Initialize script
local function initialize()
    print("Loading Nanashi Hub AFS...")
    
    scriptData.worlds = Utils.getWorlds()
    scriptData.mobs = Utils.getMobs()
    scriptData.eggs = Utils.getEggs()
    
    local ui = createFluentUI()
    if not ui then
        warn("Failed to load UI")
        return
    end
    
    startMainLoops()
    
    Toggles.antiAfk = true
    scriptFunctions.initAntiAfk()
   
    createToggleButton()
    
    print("Nanashi Hub AFS loaded successfully!")
end

initialize()